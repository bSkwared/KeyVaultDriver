/* Author:  Keith Shomper
 * Date:    8 Nov 2016
 * Purpose: Supports HW4 for CS3320 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "key_vault.h"

/* the key vault */
struct key_vault v;

/* init_vault:  initializes the key vault */
int  init_vault (int size) {
   /* allocate memory for the key vault */
   v.num_users = 0;
   v.ukey_data = (struct kv_list_h *) calloc(size, sizeof(struct kv_list_h));

   /* if error with allocation, return FALSE */
   if (v.ukey_data == NULL) return FALSE;

   /* otherwise, set the num_users field accordingly */
   v.num_users = size;
   return TRUE;
}

/* dump_vault:  prints the contents of the vault to stdout */
void dump_vault (void) {
   struct kv_list_h *udata = v.ukey_data;
   int               uid;
   
   /* print the keys for each user */
   for (uid = 0; uid < v.num_users; uid++) {
      int    n          = udata[uid].num_keys;
      struct kv_list *l = udata[uid].data;
      int    i, cnt;

      printf("Key-value pairs for user %d:\n", uid+1);

      /* print the individual key-value pairs */
      for (i = 0; i < n; i++) {
			printf("Key (%s):Values (", l[i].kv.key);
         char val[MAX_KEY_USER][MAX_VAL_SIZE];
         if ((cnt = retrieve_val(uid+1, l[i].kv.key, val))){
            int j;
            /* print value(s) for this key */
            for (j = 0; j < cnt-1; j++) {
               printf("%s ", val[j]);
            }
            printf("%s)\n", val[cnt-1]);
         } else {
            fprintf(stderr, "No values retrieved for key %s\n", l[i].kv.key);
         }
      }
   }
}

/* close_vault:  releases the allocated memory for the vault */
void close_vault (void) {
   /* no data allocated, simply return */
   if (v.ukey_data == NULL) return;

   /* release allocations for each user */
   int i;
   for (i = 0; i < v.num_users; i++) {
      
      /* if memory was allocated to this user, release it */
      if (v.ukey_data[i].data != NULL) {

         /* free memory for each chain of linked-list values */
         int n = v.ukey_data[i].num_keys;
         int k;
         for (k = 0; k < n; k++){
            free_list(v.ukey_data[i].data[k].next);
         }

         /* free the allcoated memory for this user */
         free (v.ukey_data[i].data);
      }
   }

   /* free the array of user data */
   free (v.ukey_data);
}

/* insert_pair:  inserts the key-value pair for given uid into the vault */
int  insert_pair (int uid, char *key, char *val) {

   /* key-value pairs not kept for this uid, return FALSE */
   if (uid < 1 || uid > v.num_users) return FALSE;

   /* locate the given user's key data */
   struct kv_list_h *user = &v.ukey_data[uid-1];

   /* if first key for this user, then we need to allocate memory */
   if (user->num_keys == 0) {
      user->data = (struct kv_list *) calloc(MAX_KEY_USER, sizeof(struct kv_list));

      /* if allocation fails, then return false */
      if (user->data == NULL) return FALSE;
   }
   
   /* scan this user's keys for duplicates */
   struct kv_list *l = user->data;
   int i;
   for (i = 0; i < user->num_keys; i++) {
      /* duplicate key found, exit loop */
      if (strncmp(l[i].kv.key, key, MAX_KEY_SIZE) == 0) break;
   }

   /* no more new keys permitted for this user, return FALSE */
   if (i == MAX_KEY_USER) return FALSE;

   int rc = insert_in_list(&l[i], key, val);

   /* key was successfully inserted */
   if (rc) {

      /* inserted key was a new (non-duplicate) key */
      if (i == user->num_keys) user->num_keys++;

   /* or not */
   } else {
       fprintf(stderr, "Error inserting key %s for user %d\n", key, uid);
   }

   return rc;
}

/* retrieve_val:  retrieves value(s) for key for given uid */
int  retrieve_val (int uid, char *key, char val[MAX_KEY_USER][MAX_VAL_SIZE]) {
   
   /* key-value pairs not kept for this uid, return 0 */
   if (uid < 1 || uid > v.num_users) return 0;

   /* locate the given user's key data */
   struct kv_list_h *user = &v.ukey_data[uid-1];
   
   /* scan this user's keys for match */
   struct kv_list *l = user->data;
   int i;
   for (i = 0; i < user->num_keys; i++) {
      /* key found, exit loop */
      if (strncmp(l[i].kv.key, key, MAX_KEY_SIZE) == 0) break;
   }

   /* if key not found, return 0 */
   if (i == user->num_keys) return 0;

   /* key was found, retrive cnt associated value(s) */
   int cnt = 0;
   l = &l[i];
   while (l != NULL) {
      strncpy(val[cnt], l->kv.val, MAX_VAL_SIZE);
      cnt++;
      l = l->next;
   }

   return cnt;
}

/* free_list:  releases any allocated memory in tail of incoming list */
void free_list(struct kv_list *tail) {
   /* if tail is NULL, then nothing to free */
   if (tail == NULL) return;

   struct kv_list *d = tail;
   tail = tail->next;
	free(d);
}

/* insert_in_list:  inserts the key-value pair into list l */
int  insert_in_list (struct kv_list *l, char *key, char *val) {

   /* key value is present, so allocate a list element to hold the new value */
   if (l->kv.key[0] != '\0') {

      /* use tail to ref tail of the list while a new element is allocated */
      struct kv_list *tail = l->next;
      l->next = (struct kv_list *) malloc(sizeof(struct kv_list));

      /* if malloc failed, return FALSE */
      if (l->next == NULL) return FALSE;

      /* advance l to ref the new element and reattach tail */
      l       = l->next;
      l->next = tail;
   }

   /* copy the key-value pair into the referenced list element */
   strncpy(l->kv.key, key, MAX_KEY_SIZE);
   strncpy(l->kv.val, val, MAX_VAL_SIZE);

   return TRUE;
}

